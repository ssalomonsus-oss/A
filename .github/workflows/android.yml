name: CI — ensure Dobby + Android native build

on:
  workflow_dispatch:
    inputs:
      dobby_repo_url:
        description: 'Optional: git URL to clone Dobby into app/src/main/cpp/extern/Dobby if missing. Default public jmpews/Dobby.'
        required: false
        default: 'https://github.com/jmpews/Dobby.git'
      clone_dobby:
        description: 'If "true", clone Dobby when missing. Set false to rely only on submodules/present files.'
        required: false
        default: 'true'
      private_token_secret:
        description: 'Name of the secret that contains a token for private Dobby repo (e.g. GH_TOKEN). Leave blank to clone publicly.'
        required: false
        default: ''

  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: write

env:
  ANDROID_SDK_ROOT: /usr/local/lib/android/sdk

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository (with submodules)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Show quick repo status (debug)
        run: |
          echo "pwd: $(pwd)"
          echo "Top-level files:"
          ls -la || true
          echo ".gitmodules (if any):"
          if [ -f .gitmodules ]; then cat .gitmodules; else echo "<none>"; fi
          echo "Listing app/src/main/cpp extern tree:"
          ls -la app/src/main/cpp || true
          ls -la app/src/main/cpp/extern || true

      - name: Ensure extern/Dobby exists (clone fallback if missing)
        id: ensure_dobby
        run: |
          set -euo pipefail
          TARGET="app/src/main/cpp/extern/Dobby"
          if [ -d "$TARGET" ]; then
            echo "Dobby already present at $TARGET"
            echo "status=present" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "${{ github.event.inputs.clone_dobby }}" != "true" ]; then
            echo "clone_dobby=false and Dobby missing — continuing and build may fail"
            echo "status=missing" >> $GITHUB_OUTPUT
            exit 0
          fi

          URL="${{ github.event.inputs.dobby_repo_url }}"
          if [ -z "$URL" ]; then
            echo "No dobby_repo_url provided — skipping clone (build may fail)"
            echo "status=missing" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Dobby not found — cloning from $URL into $TARGET"

          mkdir -p "$(dirname "$TARGET")"

          # If user supplied a secret name, use it for private repo cloning. Else clone public.
          SECRET_NAME="${{ github.event.inputs.private_token_secret }}"
          if [ -n "$SECRET_NAME" ]; then
            echo "Using provided secret name '$SECRET_NAME' to clone private repo."
            # Resolve secret value (will be empty if not set); user must set repo secret with this name
            TOKEN="${{ secrets[github.event.inputs.private_token_secret] || '' }}"
            if [ -z "$TOKEN" ]; then
              echo "Secret '$SECRET_NAME' not set or empty. Attempting public clone of $URL"
              git clone --depth 1 "$URL" "$TARGET"
            else
              # Convert https://github.com/owner/repo.git -> https://x-access-token:TOKEN@github.com/owner/repo.git
              # NOTE: Keep token usage secure and stored in GitHub Secrets.
              PROTO_HOST=$(echo "$URL" | sed -n 's#^\(https://\)\(.*\)#\1\2#p' || true)
              if echo "$URL" | grep -qi '^https://'; then
                # insert token
                CLONE_URL=$(echo "$URL" | sed -E "s#https://#https://x-access-token:${TOKEN}@#")
                git clone --depth 1 "$CLONE_URL" "$TARGET"
              else
                echo "Private token cloning only supports HTTPS URLs. Attempting direct git clone of $URL"
                git clone --depth 1 "$URL" "$TARGET"
              fi
            fi
          else
            # public clone
            git clone --depth 1 "$URL" "$TARGET"
          fi

          echo "status=cloned" >> $GITHUB_OUTPUT

      - name: Confirm Dobby location (debug)
        run: |
          echo "dobby check:"
          if [ -d app/src/main/cpp/extern/Dobby ]; then
            echo "-> app/src/main/cpp/extern/Dobby exists"
            ls -la app/src/main/cpp/extern/Dobby | sed -n '1,120p' || true
          else
            echo "-> app/src/main/cpp/extern/Dobby NOT present"
            find app/src/main/cpp -maxdepth 4 -type d -iname '*dobby*' -print || true
          fi

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: gradle

      - name: Install Android cmdline-tools, NDK & CMake (if missing)
        run: |
          set -euo pipefail
          mkdir -p $ANDROID_SDK_ROOT/cmdline-tools
          if [ ! -x "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" ]; then
            echo "Installing Android command-line tools..."
            cd /tmp
            curl -fsSL -o commandlinetools.zip "https://dl.google.com/android/repository/commandlinetools-linux-8512546_latest.zip"
            unzip -q commandlinetools.zip
            rm -f commandlinetools.zip
            mkdir -p $ANDROID_SDK_ROOT/cmdline-tools/latest
            mv cmdline-tools/* $ANDROID_SDK_ROOT/cmdline-tools/latest/
          fi
          export PATH=$ANDROID_SDK_ROOT/cmdline-tools/latest/bin:$PATH
          # Adjust package versions if your project requires other platform/build-tools/ndk/cmake versions
          yes | sdkmanager --sdk_root=${ANDROID_SDK_ROOT} "platform-tools" "platforms;android-33" "build-tools;33.0.2" "ndk;26.1.10909125" "cmake;3.22.1" || true

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Run Gradle assembleDebug (capture full output)
        id: gradle_run
        continue-on-error: true
        run: |
          set -o pipefail
          ./gradlew :app:assembleDebug --stacktrace --info 2>&1 | tee gradle_full.log
          echo "exit_code=$?" >> $GITHUB_OUTPUT

      - name: Gather CMake/Ninja logs and upload artifact
        if: always()
        run: |
          set -euo pipefail || true
          mkdir -p native_logs
          cp -v gradle_full.log native_logs/ || true
          if [ -d app/.cxx ]; then
            find app/.cxx -type f -print -exec cp --parents {} native_logs/ \; || true
          fi
          find . -type f -name 'CMakeError.log' -o -name 'CMakeOutput.log' -o -name 'build.ninja' -o -name 'CMakeCache.txt' -print -exec cp --parents {} native_logs/ \; || true
          tar -czf native_logs.tgz native_logs || true
          ls -lh native_logs.tgz || true

      - name: Print first probable native error snippet (fail clearly if build failed)
        if: always()
        run: |
          set -euo pipefail
          LOG=gradle_full.log
          if [ ! -f "$LOG" ]; then
            echo "No gradle_full.log found — failing for inspection"
            exit 1
          fi

          ERR_LINE=$(awk 'BEGIN{IGNORECASE=1} /fatal error:|undefined reference to|ld: error|cmake error|CMake Error| error: / { print NR; exit }' "$LOG" || true)
          if [ -z "$ERR_LINE" ]; then
            echo "No obvious native compiler/linker/configure error detected by heuristic search."
            echo "Printing last 400 lines of gradle_full.log:"
            tail -n 400 "$LOG" || true
            echo "Full logs uploaded as artifact 'native-build-logs'. Failing to force inspection."
            exit 1
          fi

          START=$(( ERR_LINE > 20 ? ERR_LINE - 20 : 1 ))
          END=$(( ERR_LINE + 80 ))
          echo "==== Probable native error at gradle_full.log line $ERR_LINE ===="
          sed -n "${START},${END}p" "$LOG" || true
          echo "==== End snippet ===="
          echo "Full logs uploaded as artifact 'native-build-logs'."
          exit 1

      - name: Upload native build logs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: native-build-logs
          path: |
            gradle_full.log
            native_logs.tgz
            native_logs/
